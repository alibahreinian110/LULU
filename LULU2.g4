grammar LULU2;
program: ft_def+ EOF;
test: expr EOF;
ft_def: (type_def | fun_def);
type_def: Type ID (':' ID)? '{' component+ '}';
component: access_modifier? (var_def | fun_def);
access_modifier: Private | Public | Protected;
var_def: Const?  type_  var_val (',' var_val)* ';';
type_: Int | Bool | Float | String | ID;
var_val: ref ('=' expr)?;
fun_def: ('(' args_var ')' '=')? Function ID '(' args_var? ')' block;
args_var: type_ ('['']')* ID | args_var ',' type_ ('['']')* ID;
block: '{' (var_def|stmt)* '}';
stmt: assign ';' | func_call ';' | cond_stmt | loop_stmt | Break ';' | Continue ';' | Destruct ('['']')* ID ';';
assign: (var | '(' var (',' var)* ')') '=' expr;
var: ((This | Super) Dot)? ref (Dot ref)*;
ref: ID ('[' expr ']')*;
expr: unary_op expr | expr arithmetic1 expr | expr arithmetic2 expr| expr (relational1|relational3) expr | expr relational2 expr | expr bitwise expr | expr logical expr
| '(' expr ')' |  const_val | Allocate handle_call | func_call | var | list_ | Nil;
func_call: (var Dot)? handle_call | Read '(' ')' | Write '(' expr ')';
list_ : '[' (expr | list_) (','(expr | list_))* ']';
handle_call: ID '(' params? ')';
params: expr | expr ',' params;
cond_stmt: If expr (block | stmt) (Else (block | stmt))? | Switch var '{' switch_body '}' ;
switch_body: (Caseof Int_const ':' block)+ (Default ':' block)?;
loop_stmt: For (type_?assign)? ';' expr ';' assign? block | While expr( block | stmt );
const_val: Int_const  | Float_const |  String_const | Bool_const;
unary_op: '-' | '!' | '~';
arithmetic1: '*' | '/' | '%';
arithmetic2: '+' | '-';
bitwise: '&' | '|';
logical: '||' | '&&';
relational1: '<=' | '>=';
relational2: '==' | '!=';
relational3: '<' | '>';

Allocate: 'allocate';
Bool: 'bool';
Break: 'break';
Caseof: 'caseof';
Const: 'const';
Continue: 'continue';
Default: 'default';
Destruct: 'destruct';
Else: 'else';
FALSE: 'false';
Function: 'function';
Float: 'float';
For: 'for';
If : 'if';
Int: 'int';
Nil : 'nil';
Private: 'private';
Protected: 'protected';
Public: 'public';
Read: 'read';
String: 'string';
Super: 'super';
Switch : 'switch';
This : 'this';
TRUE: 'true';
Type: 'type';
While: 'while';
Write: 'write';
Dot : '.';

Int_const: DEC | HEX;
Float_const: ( (Int_const? '.' Int_const) | (Int_const '.') ) EX?|(Int_const)  EX ;
String_const: ['](EXC_BS|SCAPE)*?['];
Bool_const: TRUE | FALSE;
ID: ('@'|'_'|LETTER)('@'|'_'|LETTER|DIGIT)*;


WHITESPACE: [ \t\r\n]+ ->    skip;
Comment:  ( '$$'.*?'$$') -> skip;


fragment SCAPE: '\\n' |'\\r' | '\\t' | '\\\\' | '\\\''  |'\\0'|'\\'[hH][a-fA-F0-9][a-fA-F0-9] ;
fragment EXC_BS: ~('\\');
fragment DEC: DIGIT+;
fragment HEX:('0h'|'0H')[0-9a-fA-F]+;
fragment DIGIT : [0-9];
fragment LETTER: [a-zA-Z];
fragment EX: '^'[-+]?Int_const;
